import { Address } from 'viem'
import BigNumber from 'bignumber.js'
import { SUPPORTED_NETWORKS, SupportedNetwork } from './config'
import { RAY, rayDiv, rayMul } from './math'
import { calculateOverlap, createSegments } from './utils'
import { fetchBlockchainData } from './blockchainData'
import { BalanceSnapshot, ReserveData, ReserveFactor } from './types'

/**
 * Context object containing all data required for Aave protocol revenue calculations.
 *
 * **Purpose**: Aggregates blockchain data, pricing information, and user balance history
 * needed to calculate protocol revenue from lending/borrowing activities.
 */
interface RevenueCalculationContext {
  startReserveData: Map<Address, ReserveData>
  endReserveData: Map<Address, ReserveData>
  reserveFactorHistory: Map<Address, ReserveFactor[]>
  startBalances: Map<Address, bigint>
  balanceHistory: Map<Address, BalanceSnapshot[]>
  tokenUSDPrices: Map<Address, BigNumber>
  startTimestamp: number
  endTimestamp: number
}

/**
 * Revenue calculation result for a specific reserve token.
 *
 * **Purpose**: Encapsulates protocol revenue generated from a single asset reserve,
 * including metadata needed for USD conversion and aggregation.
 */
interface Revenue {
  reserveTokenAddress: Address
  reserveTokenDecimals: number
  revenue: bigint
}

/**
 * Time-bounded segment with associated value for temporal calculations.
 *
 * **Purpose**: Represents discrete time periods with specific values (earnings, reserve factors)
 * used in precise revenue attribution calculations across time segments.
 */
interface Segment {
  value: bigint
  startTimestamp: number
  endTimestamp: number
}

/**
 * Calculates lending protocol revenue generated for Aave across multiple networks.
 *
 * **KPI Unit**: USD (United States Dollars)
 *
 * **Business Purpose**: Measures the interest and fee revenue attributable to a specific user's lending
 * and borrowing activity on Aave protocol. This metric quantifies the economic value generated by user
 * interactions with Aave's money markets and supports protocol revenue analysis.
 *
 * **Protocol Context**: Aave is a decentralized lending protocol that allows users to lend and borrow
 * cryptocurrencies. It generates revenue through interest rate spreads and various fees, with revenue
 * allocation determined by reserve factors set per asset market.
 *
 * **Supported Networks**: Multiple EVM-compatible networks where Aave has deployed lending pools
 *
 * **Reserve Factor Model**: Each asset market has a specific reserve factor (0-30%) that determines
 * the portion of interest that goes to the protocol treasury versus liquidity providers.
 *
 * **Data Sources**:
 * - **The Graph**: Aave subgraphs for lending/borrowing events, reserve data, and interest calculations
 * - **RPC Queries**: Reserve factors and pool configurations via Viem public client calls
 * - **Token Price API**: Historical token prices via `fetchTokenPrices` utility for USD conversion
 * - **Block Data**: Timestamps via `getBlockRange` utility for temporal filtering
 *
 * **Business Assumptions**:
 * - Revenue is derived from interest rate spreads and reserve factors applied to borrowing activity
 * - User's revenue contribution is proportional to their lending/borrowing positions within time window
 * - USD conversion uses token prices at time of each transaction for accuracy
 * - Reserve factors are applied consistently across all supported markets
 * - Interest calculations account for compound interest and variable rate changes
 *
 * **Revenue Sources**:
 * - Interest rate spreads between lending and borrowing rates
 * - Reserve factors applied to total protocol interest
 * - Liquidation fees and flash loan fees
 * - Protocol-specific fees (varies by network and governance decisions)
 *
 * **Calculation Method**:
 * 1. Queries user's lending and borrowing positions across all supported networks
 * 2. Retrieves interest accrual events and reserve factor data for each position
 * 3. Calculates protocol revenue portion using reserve factors applied to interest payments
 * 4. Applies temporal filtering to include only activity within specified time window
 * 5. Converts all amounts to USD using historical token prices at transaction timestamps
 * 6. Aggregates revenue across all networks and asset markets
 * 7. Returns total protocol revenue attributable to user's activity
 *
 * @param params - Calculation parameters
 * @param params.address - User wallet address to calculate lending protocol revenue for
 * @param params.startTimestamp - Start of time window for revenue calculation (inclusive)
 * @param params.endTimestampExclusive - End of time window for revenue calculation (exclusive)
 *
 * @returns Promise resolving to total lending protocol revenue in USD generated by user's activity
 */
export async function calculateKpi({
  address,
  startTimestamp,
  endTimestampExclusive,
}: {
  address: string
  startTimestamp: Date
  endTimestampExclusive: Date
}): Promise<number> {
  let revenue = new BigNumber(0)

  for (const network of SUPPORTED_NETWORKS) {
    revenue = revenue.plus(
      await revenueInNetwork(
        network,
        address as Address,
        startTimestamp,
        endTimestampExclusive,
      ),
    )
  }

  return revenue.toNumber()
}

/**
 * Calculates Aave protocol revenue for a specific network.
 *
 * **Business Purpose**: Isolates revenue calculation to a single blockchain network,
 * enabling network-specific analysis and parallel processing across multiple chains.
 *
 * **Calculation Process**:
 * 1. Fetches all required blockchain data for the network and time period
 * 2. Constructs calculation context with user balances, reserve data, and prices
 * 3. Calculates revenue per reserve asset using temporal segmentation
 * 4. Aggregates and converts to USD for final revenue amount
 *
 * @param network - Target Aave network for revenue calculation
 * @param userAddress - User wallet address
 * @param startTimestamp - Calculation period start
 * @param endTimestampExclusive - Calculation period end (exclusive)
 * @returns Promise resolving to total network revenue in USD
 */
async function revenueInNetwork(
  network: SupportedNetwork,
  userAddress: Address,
  startTimestamp: Date,
  endTimestampExclusive: Date,
): Promise<BigNumber> {
  const chainData = await fetchBlockchainData(
    network,
    userAddress,
    startTimestamp,
    endTimestampExclusive,
  )

  const context: RevenueCalculationContext = {
    ...chainData,
    startTimestamp: Math.floor(startTimestamp.getTime() / 1000),
    endTimestamp: Math.floor(endTimestampExclusive.getTime() / 1000),
  }

  const protocolRevenueByReserve = revenueByReserve(context)

  const revenue = totalRevenueInUSD(protocolRevenueByReserve, context)

  return revenue
}

/**
 * Calculates protocol revenue contribution for each reserve asset.
 *
 * **Business Purpose**: Breaks down total protocol revenue by individual asset reserves,
 * enabling asset-specific revenue analysis and accurate USD conversion per token type.
 *
 * @param context - Complete calculation context with all required data
 * @returns Array of revenue calculations per reserve asset
 */
function revenueByReserve(context: RevenueCalculationContext): Revenue[] {
  return [...context.endReserveData.values()].map(
    ({ reserveTokenAddress, reserveTokenDecimals, aTokenAddress }) =>
      revenueInReserve(
        reserveTokenAddress,
        reserveTokenDecimals,
        aTokenAddress,
        context,
      ),
  )
}

/**
 * Calculates protocol revenue from a specific reserve asset.
 *
 * **Business Purpose**: Determines how much protocol revenue was generated from a user's
 * interaction with a specific asset reserve (e.g., USDC, ETH) by analyzing their earnings
 * and applying the appropriate reserve factor ratios over time.
 *
 * **Methodology**:
 * - Splits user earnings into time segments based on balance changes
 * - Splits reserve factor changes into corresponding time segments
 * - Calculates overlapping periods to determine which reserve factor applies to which earnings
 * - Estimates protocol revenue using the ratio: reserveFactor / (1 - reserveFactor)
 *
 * @param reserveTokenAddress - Address of the reserve asset token
 * @param reserveTokenDecimals - Decimal places for the reserve token
 * @param aTokenAddress - Address of the corresponding aToken (interest-bearing version)
 * @param context - Calculation context with all required data
 * @returns Revenue object with calculated protocol revenue for this reserve
 */
function revenueInReserve(
  reserveTokenAddress: Address,
  reserveTokenDecimals: number,
  aTokenAddress: Address,
  context: RevenueCalculationContext,
): Revenue {
  const userEarningsSegments = splitUserEarningHistoryIntoSegments(
    reserveTokenAddress,
    aTokenAddress,
    context,
  )
  const reserveFactorSegments = splitReserveFactorHistoryIntoSegments(
    reserveTokenAddress,
    context,
  )

  let revenue = 0n
  for (const reserveFactor of reserveFactorSegments) {
    const earningsInSegment = earningsOverlappingReserveFactorSegment(
      reserveFactor,
      userEarningsSegments,
    )
    const revenueInSegment = estimateProtocolRevenue(
      earningsInSegment,
      reserveFactor.value,
    )
    revenue += revenueInSegment
  }

  return { reserveTokenAddress, reserveTokenDecimals, revenue }
}

/**
 * Converts user balance history into time-segmented earnings data.
 *
 * **Business Purpose**: Creates discrete time segments showing how much the user earned
 * from interest accrual in each period, accounting for balance changes and varying interest rates.
 *
 * **Calculation Logic**:
 * - Uses aToken scaled balances and liquidity index to calculate actual token amounts
 * - Earnings = (scaledBalance * newLiquidityIndex) - (scaledBalance * oldLiquidityIndex)
 * - Creates segments between each balance change event
 *
 * @param reserveTokenAddress - Reserve token to calculate earnings for
 * @param aTokenAddress - Corresponding aToken address
 * @param context - Calculation context with balance and reserve data
 * @returns Array of time segments with calculated earnings per period
 */
function splitUserEarningHistoryIntoSegments(
  reserveTokenAddress: Address,
  aTokenAddress: Address,
  context: RevenueCalculationContext,
): Segment[] {
  const startBalance = {
    liquidityIndex:
      context.startReserveData.get(reserveTokenAddress)?.liquidityIndex ?? 0n,
    scaledATokenBalance: context.startBalances.get(aTokenAddress) ?? 0n,
    timestamp: context.startTimestamp,
  }

  const endBalance = {
    liquidityIndex:
      context.endReserveData.get(reserveTokenAddress)?.liquidityIndex ?? 0n,
    scaledATokenBalance: 0n, // The last balance is not needed for segment creation
    timestamp: context.endTimestamp,
  }

  const history = context.balanceHistory.get(aTokenAddress) ?? []

  const combinedHistory = [startBalance, ...history, endBalance]

  return createSegments(combinedHistory, (current, next) => {
    const startBalance = rayMul(
      current.scaledATokenBalance,
      current.liquidityIndex,
    )
    const endBalance = rayMul(current.scaledATokenBalance, next.liquidityIndex)

    const earnings = endBalance - startBalance

    return {
      value: earnings,
      startTimestamp: current.timestamp,
      endTimestamp: next.timestamp,
    }
  })
}

/**
 * Converts reserve factor history into time-segmented data.
 *
 * **Business Purpose**: Creates discrete time segments showing which reserve factor
 * was active during each period, enabling precise protocol revenue calculations.
 *
 * **Reserve Factor**: Percentage of borrower interest that goes to protocol (typically 10-25%)
 *
 * @param reserveTokenAddress - Reserve token to get factor history for
 * @param context - Calculation context with reserve factor data
 * @returns Array of time segments with active reserve factors per period
 */
function splitReserveFactorHistoryIntoSegments(
  reserveTokenAddress: Address,
  context: RevenueCalculationContext,
): Segment[] {
  const startReserveFactor =
    context.startReserveData.get(reserveTokenAddress)?.reserveFactor ?? 0n
  const history = context.reserveFactorHistory.get(reserveTokenAddress) ?? []

  const combinedHistory = [
    {
      reserveFactor: startReserveFactor,
      timestamp: context.startTimestamp,
    },
    ...history,
    {
      reserveFactor: 0n, // The last reserve factor is not needed for segment creation
      timestamp: context.endTimestamp,
    },
  ]

  return createSegments(combinedHistory, (current, next) => ({
    value: current.reserveFactor,
    startTimestamp: current.timestamp,
    endTimestamp: next.timestamp,
  }))
}

/**
 * Calculates user earnings that overlap with a specific reserve factor time period.
 *
 * **Business Purpose**: Determines which portion of user earnings occurred during
 * a specific reserve factor period, enabling accurate protocol revenue attribution.
 *
 * **Overlap Calculation**: Uses time-weighted proportional allocation for earnings
 * that span multiple reserve factor periods.
 *
 * @param reserveFactor - Reserve factor segment to calculate overlap for
 * @param userEarnings - Array of user earning segments
 * @returns Total user earnings that overlap with the reserve factor period
 */
function earningsOverlappingReserveFactorSegment(
  reserveFactor: Segment,
  userEarnings: Segment[],
): bigint {
  let userEarningsInSegment = 0n

  for (const userEarning of userEarnings) {
    if (userEarning.value <= 0n) {
      continue
    }

    const overlap = calculateOverlap(
      userEarning.startTimestamp,
      userEarning.endTimestamp,
      reserveFactor.startTimestamp,
      reserveFactor.endTimestamp,
    )

    if (overlap > 0) {
      const duration = userEarning.endTimestamp - userEarning.startTimestamp
      const overlapRatio = rayDiv(BigInt(overlap), BigInt(duration))
      userEarningsInSegment += rayMul(userEarning.value, overlapRatio)
    }
  }

  return userEarningsInSegment
}

/**
 * Estimates protocol revenue based on user earnings and reserve factor.
 *
 * **Business Purpose**: Converts user deposit earnings into equivalent protocol revenue
 * using the mathematical relationship between depositor returns and protocol fees.
 *
 * **Mathematical Model**:
 * - Total borrower interest = User earnings + Protocol revenue
 * - User earnings = Total interest × (1 - reserveFactor)
 * - Protocol revenue = Total interest × reserveFactor
 * - Therefore: Protocol/User ratio = reserveFactor / (1 - reserveFactor)
 *
 * **Example**: If reserve factor is 20% (0.2):
 * - Users get 80% of borrower interest
 * - Protocol gets 20% of borrower interest
 * - Ratio = 0.2 / 0.8 = 0.25 (protocol gets 25% of what users earned)
 *
 * @param userEarnings - Amount earned by user from deposits
 * @param reserveFactor - Reserve factor percentage (in basis points, where 10000 = 100%)
 * @returns Estimated protocol revenue corresponding to the user earnings
 */
function estimateProtocolRevenue(
  userEarnings: bigint,
  reserveFactor: bigint,
): bigint {
  const BIPS = 10_000n // 100% = 10,000 bips

  const protocolEarningsShare = reserveFactor * RAY
  const userEarningsShare = (BIPS - reserveFactor) * RAY

  const protocolToUserEarningsRatio = rayDiv(
    protocolEarningsShare,
    userEarningsShare,
  )

  return rayMul(userEarnings, protocolToUserEarningsRatio)
}

/**
 * Converts all protocol revenue amounts to USD and calculates total.
 *
 * **Business Purpose**: Aggregates revenue across all reserve assets into a single
 * USD amount for standardized reporting and cross-protocol comparison.
 *
 * **Conversion Process**:
 * 1. For each reserve asset, gets current USD price
 * 2. Adjusts revenue amount for token decimals
 * 3. Multiplies by USD price to get revenue value
 * 4. Sums all USD values for total revenue
 *
 * @param protocolRevenueByReserve - Array of revenue calculations per reserve asset
 * @param context - Calculation context with token price data
 * @returns Total protocol revenue in USD across all reserve assets
 */
function totalRevenueInUSD(
  protocolRevenueByReserve: Revenue[],
  context: RevenueCalculationContext,
): BigNumber {
  let totalRevenueInUSD = new BigNumber(0)

  for (const {
    reserveTokenAddress,
    reserveTokenDecimals,
    revenue,
  } of protocolRevenueByReserve) {
    const tokenPrice = context.tokenUSDPrices.get(reserveTokenAddress)!

    const revenueInUSD = new BigNumber(revenue.toString())
      .multipliedBy(tokenPrice)
      .shiftedBy(-reserveTokenDecimals)

    totalRevenueInUSD = totalRevenueInUSD.plus(revenueInUSD)
  }

  return totalRevenueInUSD
}
