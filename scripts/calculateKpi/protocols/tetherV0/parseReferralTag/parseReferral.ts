import { Address, bytesToHex, decodeAbiParameters, Hex, hexToBytes } from 'viem'
import { alignMagicPrefixAndPadHex } from './alignMagicPrefixAndPadHex'

const SUPPORTED_FORMAT_IDS = [0, 1] as const
// Magic prefix is keccak256("divvi").slice(2, 10)
export const DIVVI_MAGIC_PREFIX = '6decb85d'

export type SupportedFormatId = (typeof SUPPORTED_FORMAT_IDS)[number]

export type ParseReferralErrorType =
  | 'too-short'
  | 'length-mismatch'
  | 'prefix-mismatch'
  | 'unsupported-formatId'
  | 'abi-decode-failed'
  | 'user-mismatch'
  | 'no-referral'

export type ParsedReferral = {
  user: Address
  consumer: Address
  providers: readonly Address[]
}

export type ParseReferralResult =
  | { referral: ParsedReferral; tagFormatId: SupportedFormatId; error?: never }
  | {
      referral?: never
      tagFormatId: SupportedFormatId | undefined
      error: { type: ParseReferralErrorType; message: string }
    }

function createTooShortError(
  tagFormatId?: SupportedFormatId,
): ParseReferralResult {
  return {
    tagFormatId: tagFormatId ?? undefined,
    error: {
      type: 'too-short',
      message: `Invalid Divvi referral data: The transaction calldata is too short (less than 4 bytes) to contain the required Divvi referral tag. This usually means the Divvi referral tag was not included, or the data itself is incomplete.`,
    },
  }
}

function createLengthMismatchError(
  tagFormatId?: SupportedFormatId,
): ParseReferralResult {
  return {
    tagFormatId: tagFormatId ?? undefined,
    error: {
      type: 'length-mismatch',
      message:
        'Invalid Divvi referral data: The length encoded in the referral data suffix (last 4 bytes) is greater than the total data length. This suggests the referral data may be corrupted or was not correctly included. Please verify your `@divvi/referral-sdk` integration.',
    },
  }
}

function createUnsupportedFormatError(formatId?: number): ParseReferralResult {
  const message =
    formatId !== undefined
      ? `The format ID '${formatId}' found in the referral data is not recognized. This might indicate an issue with the \`@divvi/referral-sdk\` version or corruption of the referral data. Supported format IDs are: ${SUPPORTED_FORMAT_IDS.join(', ')}. Please check your \`@divvi/referral-sdk\` integration and version.`
      : 'Unsupported referral format detected. Please check your `@divvi/referral-sdk` integration and version.'

  return {
    tagFormatId:
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      formatId !== undefined && SUPPORTED_FORMAT_IDS.includes(formatId as any)
        ? (formatId as SupportedFormatId)
        : undefined,
    error: {
      type: 'unsupported-formatId',
      message: `Invalid Divvi referral data: ${message}`,
    },
  }
}

function createUserMismatchError(
  tagFormatId: SupportedFormatId,
  details: { expected: Address; found: Address },
): ParseReferralResult {
  return {
    tagFormatId,
    error: {
      type: 'user-mismatch',
      message: `Invalid Divvi referral data: The user address encoded in the referral tag (${details.found}) does not match the expected user address (${details.expected}). This suggests the referral tag was generated for a different user or there's a processing issue. Please ensure the referral tag generated by the \`@divvi/referral-sdk\` corresponds to the correct user address.`,
    },
  }
}

function createAbiDecodeError(
  tagFormatId: SupportedFormatId,
): ParseReferralResult {
  const contextMessage =
    'Failed to decode the referral details (user, consumer and provider addresses).'

  return {
    tagFormatId,
    error: {
      type: 'abi-decode-failed',
      message: `Invalid Divvi referral data: ${contextMessage} This suggests the core referral information is corrupted or malformed. Please ensure the referral tag generated by the \`@divvi/referral-sdk\` was correctly included and not altered.`,
    },
  }
}

export type ParseReferralParams = {
  data: Hex
  user: Address
}

/**
 * Parse referral data from either onchain transactions.
 */
export function parseReferral(
  params: ParseReferralParams,
): ParseReferralResult {
  const { data, user } = params

  const dataBytes = hexToBytes(data)
  if (dataBytes.length < 4) {
    return createTooShortError()
  }

  // 1. Find the magic prefix, with aligned data for better for more resilient parsing
  const alignedData = alignMagicPrefixAndPadHex(data)
  const alignedDataBytes = hexToBytes(alignedData)
  const prefixIndex = alignedData.indexOf(DIVVI_MAGIC_PREFIX)

  if (prefixIndex !== -1) {
    // 2. Read the formatId
    const magicStartIndex = (prefixIndex - 2) / 2 // subtract 2 for '0x' prefix, then divide by 2 since each byte is 2 hex chars
    if (alignedDataBytes.length >= magicStartIndex + 5) {
      // +5 = magic(4) + formatId(1)
      const formatIdByte = alignedDataBytes[magicStartIndex + 4] // +4 to skip magic prefix

      // 3. Based on formatId, call appropriate parser
      switch (formatIdByte) {
        case 0:
          return parseFormat0({
            // Use the original data for format 0 parsing
            // Since it has the length suffix which must be at the end of the data
            // This means it will return an error if the prefix is not byte aligned
            // but that's the best we can do for format 0
            data,
            user,
          })
        case 1:
          return parseFormat1({
            dataBytes: alignedDataBytes,
            user,
            magicStartIndex, // position of the magic prefix in the aligned data
          })
        default:
          return createUnsupportedFormatError(formatIdByte)
      }
    }
  }

  return {
    tagFormatId: undefined,
    error: {
      type: 'no-referral',
      message: 'No referral tag found in the transaction data',
    },
  }
}

function parseFormat0({
  data,
  user,
}: {
  data: Hex
  user: Address
}): ParseReferralResult {
  // Here we use aligned data to be more resilient to malformed data
  // since we're searching for the prefix anywhere in the data
  const alignedData = alignMagicPrefixAndPadHex(data)
  const alignedDataBytes = hexToBytes(alignedData)
  // Find expectedDataPrefixHex in alignedData
  const prefixIndex = alignedData.indexOf(DIVVI_MAGIC_PREFIX)
  // Convert hex string index to byte array index: subtract 2 for '0x' prefix, then divide by 2 since each byte is 2 hex chars
  const appendedDataBytes = alignedDataBytes.slice((prefixIndex - 2) / 2)

  // ABI-encoded part: between prefix + formatId (5 bytes) and length suffix (last 4 bytes)
  const encodedDataBytes = appendedDataBytes.slice(5, -4)
  const encodedDataHex = bytesToHex(encodedDataBytes)

  try {
    const [consumer, providers] = decodeAbiParameters(
      [{ type: 'address' }, { type: 'address[]' }],
      encodedDataHex,
    )

    return {
      referral: {
        user,
        consumer,
        providers,
      },
      tagFormatId: 0,
    }
  } catch (error) {
    return createAbiDecodeError(0)
  }
}

function parseFormat1({
  dataBytes,
  user,
  magicStartIndex,
}: {
  dataBytes: Uint8Array
  user: Address | undefined
  magicStartIndex: number
}): ParseReferralResult {
  const tagBytes = dataBytes.slice(magicStartIndex)

  if (tagBytes.length < 7) {
    // minimum header size: magic(4) + formatId(1) + payloadLen(2)
    return createTooShortError(1)
  }

  // Parse format 1 header: magic(4) + formatId(1) + payloadLen(2)
  const payloadLengthBytes = tagBytes.slice(5, 7)
  const payloadLength = parseInt(bytesToHex(payloadLengthBytes), 16)

  if (tagBytes.length < 7 + payloadLength) {
    return createLengthMismatchError(1)
  }

  // Extract payload
  const payloadBytes = tagBytes.slice(7, 7 + payloadLength)
  const payloadHex = bytesToHex(payloadBytes)

  try {
    const [payloadUser, consumer, providers] = decodeAbiParameters(
      [{ type: 'address' }, { type: 'address' }, { type: 'address[]' }],
      payloadHex,
    )

    // Validate user matches
    if (user && payloadUser.toLowerCase() !== user.toLowerCase()) {
      return createUserMismatchError(1, {
        expected: user,
        found: payloadUser,
      })
    }

    return {
      referral: {
        // Use payloadUser as the actual user when user is undefined
        user: user ?? payloadUser,
        consumer,
        providers,
      },
      tagFormatId: 1,
    }
  } catch (error) {
    return createAbiDecodeError(1)
  }
}
