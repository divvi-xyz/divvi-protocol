import { Address, bytesToHex, decodeAbiParameters, Hex, hexToBytes } from 'viem'
import { alignMagicPrefixAndPadHex } from './alignMagicPrefixAndPadHex'

const SUPPORTED_FORMAT_IDS = [1] as const
// Magic prefix is keccak256("divvi").slice(2, 10)
export const DIVVI_MAGIC_PREFIX = '6decb85d'

export type SupportedFormatId = (typeof SUPPORTED_FORMAT_IDS)[number]

export type ParseReferralErrorType =
  | 'too-short'
  | 'length-mismatch'
  | 'prefix-mismatch'
  | 'unsupported-formatId'
  | 'abi-decode-failed'
  | 'user-mismatch'

export type ParsedReferral = {
  user: Address
  consumer: Address
  providers: readonly Address[]
}

export type ParseReferralResult =
  | { referral: ParsedReferral; tagFormatId: SupportedFormatId; error?: never }
  | {
      referral?: never
      tagFormatId: SupportedFormatId | undefined
      error: { type: ParseReferralErrorType; message: string }
    }

type ReferralType = 'onchain' | 'offchain'

function createTooShortError(
  referralType: ReferralType,
  tagFormatId?: SupportedFormatId,
): ParseReferralResult {
  const sourceType =
    referralType === 'onchain' ? 'transaction calldata' : 'signed message data'
  return {
    tagFormatId: tagFormatId ?? undefined,
    error: {
      type: 'too-short',
      message: `Invalid Divvi referral data: The ${sourceType} is too short (less than 4 bytes) to contain the required Divvi referral tag. This usually means the Divvi referral tag was not included, or the data itself is incomplete.`,
    },
  }
}

function createLengthMismatchError(
  referralType: ReferralType,
  tagFormatId?: SupportedFormatId,
): ParseReferralResult {
  const message =
    referralType === 'onchain'
      ? 'Invalid Divvi referral data: The length encoded in the referral data suffix (last 4 bytes) is greater than the total data length. This suggests the referral data may be corrupted or was not correctly included. Please verify your `@divvi/referral-sdk` integration.'
      : 'Invalid Divvi referral data: The payload length specified in the referral tag header exceeds the available data length. This suggests the referral tag was truncated or corrupted during processing. Please verify your `@divvi/referral-sdk` integration and ensure the complete referral tag was included.'

  return {
    tagFormatId: tagFormatId ?? undefined,
    error: {
      type: 'length-mismatch',
      message,
    },
  }
}

function createUnsupportedFormatError(
  referralType: ReferralType,
  formatId?: number,
): ParseReferralResult {
  const message =
    formatId !== undefined
      ? `The format ID '${formatId}' found in the referral data is not recognized. This might indicate an issue with the \`@divvi/referral-sdk\` version or corruption of the referral data. Supported format IDs are: ${SUPPORTED_FORMAT_IDS.join(', ')}. Please check your \`@divvi/referral-sdk\` integration and version.`
      : referralType === 'offchain' && formatId === 0
        ? 'Format 0 is not supported for offchain referrals. Only format 1 and above are supported for offchain referrals. Please use a newer version of `@divvi/referral-sdk` that supports format 1+ for offchain referrals.'
        : 'Unsupported referral format detected. Please check your `@divvi/referral-sdk` integration and version.'

  return {
    tagFormatId:
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      formatId !== undefined && SUPPORTED_FORMAT_IDS.includes(formatId as any)
        ? (formatId as SupportedFormatId)
        : undefined,
    error: {
      type: 'unsupported-formatId',
      message: `Invalid Divvi referral data: ${message}`,
    },
  }
}

function createUserMismatchError(
  _referralType: ReferralType,
  tagFormatId: SupportedFormatId,
  details: { expected: Address; found: Address },
): ParseReferralResult {
  return {
    tagFormatId,
    error: {
      type: 'user-mismatch',
      message: `Invalid Divvi referral data: The user address encoded in the referral tag (${details.found}) does not match the expected user address (${details.expected}). This suggests the referral tag was generated for a different user or there's a processing issue. Please ensure the referral tag generated by the \`@divvi/referral-sdk\` corresponds to the correct user address.`,
    },
  }
}

function createAbiDecodeError(
  _referralType: ReferralType,
  tagFormatId: SupportedFormatId,
): ParseReferralResult {
  const contextMessage =
    'Failed to decode the referral details (user, consumer and provider addresses).'

  return {
    tagFormatId,
    error: {
      type: 'abi-decode-failed',
      message: `Invalid Divvi referral data: ${contextMessage} This suggests the core referral information is corrupted or malformed. Please ensure the referral tag generated by the \`@divvi/referral-sdk\` was correctly included and not altered.`,
    },
  }
}

export type ParseReferralParams = {
  referralType: 'onchain'
  data: Hex
  user: Address
}

/**
 * Parse referral data from either onchain transactions or offchain signed messages.
 */
export function parseReferral(
  params: ParseReferralParams,
): ParseReferralResult {
  const { referralType, data, user } = params

  const dataBytes = hexToBytes(data)
  if (dataBytes.length < 4) {
    return createTooShortError(referralType)
  }

  // 1. Find the magic prefix, with aligned data for better for more resilient parsing
  const alignedData = alignMagicPrefixAndPadHex(data)
  const alignedDataBytes = hexToBytes(alignedData)
  const prefixIndex = alignedData.indexOf(DIVVI_MAGIC_PREFIX)

  if (prefixIndex !== -1) {
    // 2. Read the formatId
    const magicStartIndex = (prefixIndex - 2) / 2 // subtract 2 for '0x' prefix, then divide by 2 since each byte is 2 hex chars
    if (alignedDataBytes.length >= magicStartIndex + 5) {
      // +5 = magic(4) + formatId(1)
      const formatIdByte = alignedDataBytes[magicStartIndex + 4] // +4 to skip magic prefix

      // 3. Based on formatId, call appropriate parser
      switch (formatIdByte) {
        case 1:
          return parseFormat1({
            referralType,
            dataBytes: alignedDataBytes,
            user,
            magicStartIndex, // position of the magic prefix in the aligned data
          })
        default:
          return createUnsupportedFormatError(referralType, formatIdByte)
      }
    }
  }

  return createUnsupportedFormatError(referralType)
}

function parseFormat1({
  referralType,
  dataBytes,
  user,
  magicStartIndex,
}: {
  referralType: ReferralType
  dataBytes: Uint8Array
  user: Address | undefined
  magicStartIndex: number
}): ParseReferralResult {
  const tagBytes = dataBytes.slice(magicStartIndex)

  if (tagBytes.length < 7) {
    // minimum header size: magic(4) + formatId(1) + payloadLen(2)
    return createTooShortError(referralType, 1)
  }

  // Parse format 1 header: magic(4) + formatId(1) + payloadLen(2)
  const payloadLengthBytes = tagBytes.slice(5, 7)
  const payloadLength = parseInt(bytesToHex(payloadLengthBytes), 16)

  if (tagBytes.length < 7 + payloadLength) {
    return createLengthMismatchError(referralType, 1)
  }

  // Extract payload
  const payloadBytes = tagBytes.slice(7, 7 + payloadLength)
  const payloadHex = bytesToHex(payloadBytes)

  try {
    const [payloadUser, consumer, providers] = decodeAbiParameters(
      [{ type: 'address' }, { type: 'address' }, { type: 'address[]' }],
      payloadHex,
    )

    // Validate user matches
    if (user && payloadUser.toLowerCase() !== user.toLowerCase()) {
      return createUserMismatchError(referralType, 1, {
        expected: user,
        found: payloadUser,
      })
    }

    return {
      referral: {
        // Use payloadUser as the actual user when user is undefined
        user: user ?? payloadUser,
        consumer,
        providers,
      },
      tagFormatId: 1,
    }
  } catch (error) {
    return createAbiDecodeError(referralType, 1)
  }
}
