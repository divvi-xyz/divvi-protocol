import {
  BeefyInvestorTransactionWithUsdBalance,
  BeefyVaultTvlData,
  VaultInfo,
} from './types'
import { getStrategyContract } from '../utils/viem'
import { RevenueResult, NetworkId } from '../../../types'
import { getVaults } from './getVaults'

/**
 * Given a list of transaction history on a particular Beefy vault and a timestamp,
 * returns a user's TVL in the vault at the specified time.
 */
export function getUserTvl(
  txHistory: BeefyInvestorTransactionWithUsdBalance[],
  timestamp: Date,
): number {
  let lastTvl = txHistory[0].usd_balance
  for (const tx of txHistory) {
    if (new Date(tx.datetime) >= timestamp) {
      return lastTvl
    }
    lastTvl = tx.usd_balance
  }
  return lastTvl
}

/**
 * Given a list of Beefy vault TVL data and a timestamp, returns the vault's TVL at
 * the specified time.
 */
export function getVaultTvl(
  tvlHistory: BeefyVaultTvlData[],
  timestamp: Date,
): number {
  let lastTvl = tvlHistory[0][1]
  for (const tvl of tvlHistory) {
    if (new Date(tvl[0]) >= timestamp) {
      return lastTvl
    }
    lastTvl = tvl[1]
  }
  return lastTvl
}

/**
 * Given historical information about a vault and a user's transactions, calculates the amount of fee
 * revenue generated by the user's interaction with the vault, denominated in the native currency
 * of the chain the vault is deployed on.
 */
export async function calculateVaultRevenue(vaultInfo: VaultInfo): Promise<{
  tokenId: string
  revenue: string
}> {
  let totalRevenueContribution = 0n
  for (const { beefyFee, timestamp } of vaultInfo.feeEvents) {
    const userTvl = getUserTvl(vaultInfo.txHistory, timestamp)
    const vaultTvl = getVaultTvl(vaultInfo.vaultTvlHistory, timestamp)
    const partialRevenueContribution =
      (BigInt(userTvl * 10 ** 18) * BigInt(beefyFee)) /
      BigInt(vaultTvl * 10 ** 18)
    // TODO: Convert fee contributions to USD value using native token price at the time of fee collection
    // using an historical API endpoint, e.g. https://docs.coingecko.com/reference/coins-id-history
    totalRevenueContribution += partialRevenueContribution
  }

  const strategyContract = await getStrategyContract(
    vaultInfo.vaultAddress,
    vaultInfo.networkId,
  )
  const nativeTokenAddress = await strategyContract.read.native()
  const tokenId = `${vaultInfo.networkId}:${nativeTokenAddress}`
  return {
    tokenId,
    revenue: totalRevenueContribution.toString(),
  }
}

export async function calculateRevenue(
  address: string,
  startTimestamp: Date,
  endTimestamp: Date,
): Promise<RevenueResult> {
  const vaultsInfo = await getVaults(address, startTimestamp, endTimestamp)

  const revenueResult: RevenueResult = {}
  for (const vaultInfo of Object.values(vaultsInfo)) {
    const vaultRevenue = await calculateVaultRevenue(vaultInfo)
    const networkId = vaultInfo.networkId as NetworkId
    if (revenueResult?.[networkId]) {
      if (vaultRevenue.tokenId in revenueResult[networkId]) {
        revenueResult[networkId] = {
          ...revenueResult[networkId],
          [vaultRevenue.tokenId]: (
            BigInt(revenueResult[networkId][vaultRevenue.tokenId]) +
            BigInt(vaultRevenue.revenue)
          ).toString(),
        }
      } else {
        revenueResult[networkId] = {
          ...revenueResult[networkId],
          [vaultRevenue.tokenId]: vaultRevenue.revenue,
        }
      }
    } else {
      revenueResult[networkId] = {
        [vaultRevenue.tokenId]: vaultRevenue.revenue,
      }
    }
  }
  return revenueResult
}
