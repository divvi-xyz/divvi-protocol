import {
  BeefyInvestorTransactionWithUsdBalance,
  BeefyVaultTvlData,
  VaultInfo,
} from './types'
import { getStrategyContract } from '../utils/viem'
import {
  RevenueResult,
  NetworkId,
  TokenPriceData
} from '../../../types'
import { getVaults } from './getVaults'
import { fetchTokenPrices } from '../utils/tokenPrices'

/**
 * Given a list of transaction history on a particular Beefy vault and a timestamp,
 * returns a user's TVL in the vault at the specified time.
 * Requires the list of txHistory to be sorted from earliest to most-recent.
 */
export function getUserTvl(
  txHistory: BeefyInvestorTransactionWithUsdBalance[],
  timestamp: Date,
): number {
  let lastTvl = txHistory[0].usd_balance
  for (const tx of txHistory) {
    if (new Date(tx.datetime) >= timestamp) {
      return lastTvl
    }
    lastTvl = tx.usd_balance
  }
  return lastTvl
}

/**
 * Given a list of Beefy vault TVL data and a timestamp, returns the vault's TVL at
 * the specified time.
 * Requires the list of tvlHistory to be sorted from earliest to most-recent.
 */
export function getVaultTvl(
  tvlHistory: BeefyVaultTvlData[],
  timestamp: Date,
): number {
  let lastTvl = tvlHistory[0][1]
  for (const tvl of tvlHistory) {
    if (new Date(tvl[0]) >= timestamp) {
      return lastTvl
    }
    lastTvl = tvl[1]
  }
  return lastTvl
}

/**
 * Given a list of historical token prices and a timestamp, returns the nearest token price
 * to the specified time.
 * Requires the list of tokenPrices to be sorted from earliest to most-recent.
 */
export function getTokenPrice(
  tokenPrices: TokenPriceData[],
  timestamp: Date
): string {
  let lastPrice = tokenPrices[0].priceUsd
  for (const tokenPrice of tokenPrices) {
    if (new Date(tokenPrice.priceFetchedAt) >= timestamp) {
      return lastPrice
    }
    lastPrice = tokenPrice.priceUsd
  }
  return lastPrice
}
/**
 * Given historical information about a vault and a user's transactions, calculates the amount of fee
 * revenue generated by the user's interaction with the vault, denominated in the native currency
 * of the chain the vault is deployed on.
 */
export async function calculateVaultRevenue(vaultInfo: VaultInfo): Promise<{
  tokenId: string
  revenue: string
}> {
  const strategyContract = await getStrategyContract(
    vaultInfo.vaultAddress,
    vaultInfo.networkId,
  )
  const nativeTokenAddress = await strategyContract.read.native()
  const tokenId = `${vaultInfo.networkId}:${nativeTokenAddress}`

  // Fetch the historical prices of the chain's native token
  const startTimestamp = vaultInfo.feeEvents[0].timestamp
  const endTimestamp = vaultInfo.feeEvents.slice(-1).timestamp
  const tokenPrices = await fetchTokenPrices({
    tokenId,
    startTimestamp,
    endTimestamp
  })

  let totalRevenueContribution = 0n
  let totalNativeContribution = 0n

  for (const { beefyFee, timestamp } of vaultInfo.feeEvents) {
    const userTvl = getUserTvl(vaultInfo.txHistory, timestamp)
    const vaultTvl = getVaultTvl(vaultInfo.vaultTvlHistory, timestamp)
    const partialRevenueContribution =
      (BigInt(userTvl * 10 ** 18) * BigInt(beefyFee)) /
        BigInt(vaultTvl * 10 ** 18)
    totalNativeContribution += partialNativeContribution

    tokenPriceUsd = getTokenPrice(tokenPrices, new Date(timestamp))
  }

  return {
    tokenId,
    revenue: totalNativeContribution.toString(),
  }
}

export async function calculateRevenue({
  address,
  startTimestamp,
  endTimestamp,
}: {
  address: string
  startTimestamp: Date
  endTimestamp: Date
}): Promise<RevenueResult> {
  const vaultsInfo = await getVaults(address, startTimestamp, endTimestamp)

  const revenueResult: RevenueResult = {}
  for (const vaultInfo of Object.values(vaultsInfo)) {
    const vaultRevenue = await calculateVaultRevenue(vaultInfo)
    const networkId = vaultInfo.networkId as NetworkId
    if (revenueResult?.[networkId]) {
      if (vaultRevenue.tokenId in revenueResult[networkId]) {
        revenueResult[networkId] = {
          ...revenueResult[networkId],
          [vaultRevenue.tokenId]: (
            BigInt(revenueResult[networkId][vaultRevenue.tokenId]) +
            BigInt(vaultRevenue.revenue)
          ).toString(),
        }
      } else {
        revenueResult[networkId] = {
          ...revenueResult[networkId],
          [vaultRevenue.tokenId]: vaultRevenue.revenue,
        }
      }
    } else {
      revenueResult[networkId] = {
        [vaultRevenue.tokenId]: vaultRevenue.revenue,
      }
    }
  }
  return revenueResult
}
